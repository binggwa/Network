# 1. 버클리 소켓 API - 1
***
### 버클리 소켓 API
- API를 사용하면 애플리케이션 프로그램이 사전 정의된 인터페이스를 통해 특정 리소스에 액세스할 수 있음
- 네트워크 리소스에 대한 액세스를 제공하는 가장 인기있는 API는 버클리 소켓 인터페이스
- 많은 UNIX 시스템에서 널리 사용됨
### 소켓을 통한 Communications
- 소켓 API는 추상화를 통해 기본 통신 기술의 세부 정보를 최대한 숨김
- 이를 통해 프로그래머는 기본 네트워크 세부 정보에 대한 걱정 없이 애플리케이션 프로그램을 쉽게 작성할 수 있음
- 애플리케이션은 소켓에서 쓰거나 소켓에서 읽는 방식으로 소켓을 생성
- 일반적인 시나리오에서 한 응용 프로그램이 서버로, 다른 응용 프로그램이 클라이언트로 작용
- 소켓은 커널 공간 리소스이며, 디스크립터로 액세스할 수 있는 인터페이스는 사용자 공간에 있다
### Transport Protocols
- 호스트 컴퓨터는 IP를 기반으로 두 개의 전송 프로토콜을 실행하여 프로세스 간 통신을 가능하게 한다
- UDP를 사용하면 개별 정보 블록에 연결 없이 최대한 효율적으로 전송할 수 있는 반면,
- TCP를 사용하면 바이트 스트림을 안정적으로 전송할 수 있다
- 회로 인터페이스를 통해 사용할 수 있는 두가지 서비스 모드(연결 지향 및 비연결)이 있음
### TCP (Connection-oriented)
- 응용 프로그램이 먼저 연결을 설정해야 함
- 그 후 데이터가 연결을 통해 바이트 문자열의 순차적 전송으로 대상에 전달
- 전송을 보장하는 경계는 없으므로 프로그래머는 클라이언트 서버 응용 프로그램을 개발할 때 이에 주의를 기울여야 함
### UDP (Connectionless)
- 비연결 모드에서는 연결 설정 오버헤드가 없음 -> 최상의 서비스 제공
- 이 모드는 전송 시 메시지 경계가 유지되는 정보 블록 하나를 즉시 전송
- 메시지를 받았을 때, 순서가 맞지 않을 수 있으며, 심지어 메시지 손실 가능
- 위 기능이 정말 중요하다면, 프로그래머는 재전송 및 주문 처리를 처리해야 한다.
### Client & Server Differences
- 프로그래밍 서버와 클라이언트에는 몇 가지 주요 차이점이 있다
- 서버
  - 소켓을 만들 때 잘 알려져 있고 고유한 포트 번호를 지정
  - 클라이언트 요청을 수동적으로 기다림
- 클라이언트
  - 연결중에만 유효한 임시 포트 번호가 할당
  - 클라이언트가 서버와의 통신을 시작
  - 서버 IP 주소를 알아야 하며, 이 주소는 DNS 서비스에 요청하여 IP 이름과 IP 주소 간의 변환을 요청할 수 있다.
***
### Socket Calls for connection-oriented mode
- socket()
  - 서버는 패시브 오픈을 수행하여 시작
  - 호출된 소켓은 TCP 스트림 파이프를 지정하는 소켓을 만듬
  - 호출이 성공하면 소켓 디스크립터와 정수를 반환
- bind()
  - bind 호출은 서버의 로컬 IP 주소뿐만 아니라 잘 알려진 포트 번호를 소켓 디스크립터에 바인딩
  - 단, 다중 네트워크 인터페이스의 IP 주소가 삭제될 수 있음
- listen()
  - listen 호출은 소켓을 클라이언트로부터 들어오는 연결을 받아들일 수 있는 수신 소켓으로 바꿈
  - 호출에는 서버가 요청을 수락하기를 기다리는 동안 대기할 수 있는 최대 요청 수를 지정하는 매개 변수가 있음
- accept()
  - 서버 호출은 수신 요청을 수락함
  - 대기열이 비어있는 경우 블록을 수락
  - 클라이언트 측이 활성상태로 열리면 서버에 연결하는 회로가 생성됨
- 클라이언트 socket()
  - 클라이언트 호출은 연결을 시도하고 로컬 소켓에 연결을 시도함
  - 로컬 소켓은 번호에 따라 지정된 원격 주소로 지정
- 클라이언트 connect()
  - 실제로 TCP 프로토콜에 따라 연결 구축을 위한 3방향 핸드쉐이킹 프로세스가 시작
  - TCP 연결이 설정되면 서버 아래의 수락자 함수가 깨어나 지정된 연결에 대한 새 소켓 설명자를 반환
  - 이는 소스 앱 IP 주소, 소스 포트 번호, 대상 IP 주소, 대상 포트 번호로 지정됨
  - 서버의 클라이언트는 트랙 데이터 전송에 새 소켓을 사용하지만, 서버 측의 원래 소켓은 클라이언트의 새 연결 요청을 계속 수신
- write()
  - 데이터 전송의 경우 클라이언트 또는 서버는 쓰기 기능을 사용하여 연결된 소켓으로 데이터를 전송
  - 쓰기 함수 호출이 성공하면 전송된 바이트 수가 반환되며, 모든 데이터가 전송될 때까지 호출이 차단됨
- read()
  - 클라이언트는 실제 함수를 호출하여 연결된 소켓에서 데이터를 수신함
  - 호출 시 바이트 수 (success) 반환, 데이터가 도착하지 않으면 호출이 끊김
- close()
  - 클라이언트 또는 서버가 close 함수를 실행하여 TCP 연결을 종료
***
### 요약
- 소켓 API는 기본 프로토콜 및 메커니즘의 세부 정보를 숨김
***
# 2. 버클리 소켓 API - 2
***
### Connectionless (UDP)
- UDP의 비연결 모드엔 연결 설정 오버헤드가 없음
### 비연결 모드의 소켓 호출 순서
- 전체적으로 연결 지향 모드와 비슷해 보임
- socket()
  - 연결 지향 모드의 소켓 호출과 비슷함
  - 프로그래머가 소켓 생성 함수에서 UDP의 소켓 유형을 지정해야 한다는 점이 다름
- bind()
  - 서버 측의 바인딩 함수 호출은 연결 지향 모드에서의 바인딩과 동일
- recvfrom()
  - 데이터 전송의 경우 서버는 recvfrom 함수를 사용하여 소켓에서 데이터를 수신함
  - 차단 함수, 연결 지향 모드에서는 함수 이름을 읽을 수 없다는 점에 유의
- 클라이언트 socket()
  - 소켓 생성 호출은 서버에서의 소켓 생성 호출과 동일함
- sendto()
  - 데이터 전송의 경우 클라이언트는 sendto 함수를 사용하여 소켓에 데이터를 보냄
  - 연결 지향 모드에서는 함수 이름이 올바르지 않을 수 있음
- 클라이언트 recvfrom()
  - 데이터가 도착하면 서버 측 recvfrom 함수가 절전 모드로 전환됨
  - 호출에서 recv는 클라이언트가 보낸 최대 한번, 하나의 데이터그램에서 데이터를 반환
  - 여기서 정확히 TCP 스트림 서비스와 UDP 데이터그램 서비스 간의 차이점 주목
- close()
***
### TCP Echo Server
- 시스템 호출 및 함수 사용에 대한 설명으로 TCP를 통해 통신하는 두 프로그램 살펴보기
- 클라이언트는 사용자에게 한 줄의 텍스트를 입력하라는 메시지를 표시하여 서버로 보내고, 서버에서 데이터를 다시 읽는다.
- 서버는 단순한 에코 서버 역할을 한다.
- 이 예제에서 각 프로그램은 반대쪽 끝에서 고정된 수의 바이트인 최종 바이트 BUFLEN 을 예상함
### TCP Echo Server - Binding
- 바인딩 시스템 호출은 소켓에 주소를 할당하는데 사용
- bzero 함수는 데이터 구조에 할당된 메모리 주소를 비우는 것
### TCP Echo Server - Connections
- 연결 지향 서버는 listen을 호출하여 연결 요청을 수신
- listen 호출은 서버가 수락하기를 기다리는 동안 시스템이 큐에 넣어야 하는 최대 연결 요청 수를 지정해야 함
- 최대값은 일반적으로 5
### TCP Echo Server - Repeated Byte Reads
- TCP는 스트림 지향적이므로 수신된 데이터는 데이터 전송 방식에 관계없이 스트림별로 여러 부분, 즉 반대편으로 들어올 수 있음
- 따라서 프로그램은 모든 데이터가 수신될 때까지 읽기 호출을 반복해야 함
### TCP Echo Client - Name-to-Address
- 클라이언트 측에서는 서버 이름을 알고 있고, 다른 하나는 IP 주소이다
- 클라이언트는 이름을 사용하여 변환 함수 gethostbyname의 주소를 지정함
### TCP Echo Client - Connection
- 클라이언트는 connect를 호출하여 소켓에 연결을 설정함
### TCP Echo Client - Repeated reads
- 또한 모든 데이터가 수신될 때까지 읽기 호출을 반복해서 수행함
***
### UDP Echo Server
- UDP를 사용한 서버-클라이언트 예제
- recvfrom 함수를 사용하면 단 한번의 호출로 데이터를 받을 수 있음
- 따라서 UDP는 차단 지향 데이터그램 서비스임
- 함수 get time of day를 사용하여 지연시간과 같은 중요한 네트워크 통계를 수집할 수 있음
### UDP Echo Client
- UDP 모드의 서버 및 클라이언트 프로그램 모두에서 TCP 모드의 코드보다 전반적으로 읽기 및 쓰기 코드가 더 간단함
***
### 요약
- UDP Reliability
  - 통신이 근거리 통신망으로 제한되는 경우, 실제로 데이터그램 손실이 거의 발생하지 않지만, UDP는 신뢰할 수 없음
  - 그러나 광역 네트워크에서는 네트워크로 인해 데이터그램이 자주 삭제될 수 있음 -> 사용자가 직접 신뢰성 보장을 처리해야 할 수도 있음
  - 서버의 응답이 클라이언트에 도달하지 못하면 클라이언트는 영원히 기다리게 됨
  - 이 경우, 클라이언트는 타임아웃 메커니즘을 제공하고 메시지를 재전송해야 함
  - 또한 수신기에서 데이터그램을 재정렬하고 중복된 데이터그램을 폐기할 수 있도록 신뢰성을 더욱 높일 수 있음
***
# 3. 디지털 전송 기본 사항
***
- 메시지를 전송하는데 시간이 얼마나 걸릴까?
- 네트워크 시스템이 음성 또는 영상 통화를 처리할 수 있나?
- 메시지를 전송하는데 시간이 얼마나 걸리나?
- 라디오, 구리선, 광케이블을 통해 어떤 전송 속도를 낼 수 있을까?
***
### Bits, numbers, information
- 디지털 통신의 최소 단위는 값이 0 또는 1인 **_비트_**
- n비트를 사용하면 2의 n승개의 가능성을 열거 가능
- 비트가 많을수록, 컨텐츠는 많아진다
### Block vs. Stream Information
- Block
  - 텍스트, 파일, 그림과 같이 단일 블록에서 발생하는 정보
  - 사이즈 = 비트 / 블록 or 바이트 / 블록
- Stream
  - 비디오 및 오디오와 같이 스트림에서 지속적으로 생성되고 전송되는 정보
  - 사이즈 = 비트 / 초 (ex) kpbs, Mbps etc..)
### Delay - Propagation Delay
- 두 노드 간의 통신 지연에는 **_전파 지연_** 과 **_전송 지연_** 존재
- 전파 지연
  - 신호가 통신 매체를 통해 전파되는 시간, t(prop) = d/v 로 정의
  - t(prop) : time for signal to propagate across medium
  - d : distance between two nodes in meters
  - v : speed of light in the transmission medium
### Delay - Transmission Delay
- 전송 지연은 t(trans) = L/R 로 정의
- R : 전송 시스템 R의 대역폭 in bps
- L : 메시지 L의 크기 (number of bits)
- 전체 지연
  - 전파 지연과 전송 지연의 합계
- L을 줄이기 위해 데이터 압축 기법을 사용
- R을 높이려면 더 높은 대역폭의 모뎀 사용
- d를 줄이기 위해 서버를 사용자와 더 가깝게 배치
***
### Compression
- 정보는 일반적으로 효율적으로 표현되지 않는다
- 데이터 압축 기법은 더 적은 비트를 사용하여 정보를 표시
- Noiseless 데이터 압축 체계
  - 원본 데이터를 정확하게 복구할 수 있는 압축 파일을 생성
- Noisy 
  - 정보를 대략적으로 복구한다
- 압축률 = #bits (original file) / #bits (compressed file)
- 디지털 비디오 스트림에서의 블록 정보 압축의 몇가지 예
***
### Trans. of Stream Information
- 스트림 정보를 전송하는 방법에는 두가지가 있다
- Constant bit-rate (고정 비트레이트)
  - 디지털 전화 음성과 같은 신호는 안정적인 스트림을 생성
  - 네트워크는 안정적인 신호 전송을 지원해야 하며 대역폭도 필요하지 않다
- Variable bit-rate (가변 비트레이트)
  - 디지털화된 비디오와 같은 신호는 비트 전송률이 변하는 스트림을 생성
  - 네트워크는 패킷 스위칭과 같은 다양한 신호 전송 속도를 지원해야 함
***
### Stream Quality-of-Service (QoS) Issues
- 네트워크 전송 장애가 있는 경우 스트림 서비스 품질 문제가 발생함
### Transmission System
- 전송이 이루어지려면 송신자로부터 수신자에게 신호를 전달하는 전송 매체가 필요
- Transmitter (송신기)
  - 정보를 전송에 적합한 신호로 변환하고 통신 매체에 에너지를 주입
- Receiver (수신기)
  - 수신기는 매체로부터 에너지를 수신하고 수신된 신호를 사용자에게 전달하기에 적합한 형태로 변환
- Transmission Impairments
  - 전송 중에는 신호 감쇠, 신호 왜곡, 다른 신호로부터의 간섭과 같은 통신 채널 장애가 발생 가능
- Digital Long-Distance Communications
  - 장거리 통신의 경우 원본 데이터 또는 시퀀스를 커버하고 다음 세그먼트에서 재전송하려면 재생기(Regenerator)가 필요
### Twisted Pair
- 일반적으로 두께가 약 1mm인 2개의 구리선으로 구성
- cm 당 비틀림이 많을수록 크로스토크가 줄어들고 장거리에서도 품질이 향상
- 근거리에서도 높은 비트 전송률을 제공할 수 있다
- Asymmetric Digital Subscriber Loop (ADSL, 비대칭 디지털 가입자 루프)
  - 트위스트 페어 사용
- 더 짧은 거리에서는 더 높은 요금
- 대부분의 사무실 건물을 지을 때 사용
- 이더넷 LAN에서 사용하기에 좋은 후보
- 네트워크 장치의 컴퓨터 간 최대 거리는 100m 정도
### Coaxial Cable (동케이블)
- 높은 대역폭과 우수한 간섭 내성을 잘 조합한 제품
- 트위스트 페어에 비해 더 높은 대역폭 제공
- 케이블 TV 배급에 사용
- 원래는 이더넷 LAN 매체에 사용
### Optical Fiber (광섬유)
- 광섬유 전송 시스템은 1970년대 후반에 도입
- 구리선인 디지털 전송 시스템에 비해 큰 이점, 네트워크의 디지털화 속도를 가속화
- 레이저, LED와 같은 광원은 광섬유를 통해 전송되는 빛의 펄스를 생성
- 매우 먼 거리에서도 매우 빠른 속도로 작동, 오류가 거의 없다
- 비트 오류율은 10^(-15) 에 불과함
- 장점
  - Very low attenuation
  - Noise immunity
  - Extremely high bandwidth
  - Security
  - No corrosion
  - More compact, lighter than copper wire
- 단점
  - New types of optical signal impairments & dispersion
    - Wavelength dependence
  - Limited bend radius (굽힘 반경 제한)
    - if physical arc of cable too high, light lost or won't reflect
    - Will break
  - Difficult to splice
  - Mechanical vibration becomes signal noise
***
### 요약
- 디지털 전송 시스템마다 비트 전송률, 비용, 비트 오류율 및 사용량이 다양하다