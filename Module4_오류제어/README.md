# 1. 오류 제어 - Parity checks
***
### Error Control
- 디지털 전송 시스템에서는 비트당 오류 확률이 다른 오류가 발생
- 애플리케이션에서는 특정 신뢰성 수준이 필요
- 오류 제어는 전송 시스템이 애플리케이션 요구 사항을 충족하지 않을 때 사용되며,
- 오류에도 불구하고 데이터 스트림이 일정 수준의 정확도로 전송되도록 한다
- 2가지 기본 오류 제어 방식 존재
  - 오류 감지 및 재전송
  - 재전송이 필요 없는 오류 수정
***
### Codeword
- 오류 감지에 있어 중요한 용어 중 하나
- n-bit 코드워드 : m 비트 데이터에 k 비트 중복 검사 비트를 더한 프레임
- Key Idea
  - 애플리케이션에서 생성되는 정보는 인코딩되므로 통신 채널에 입력되는 코드워드로서 특정 패턴을 충족
  - 수신기는 채널에서 나오는 단어의 코드를 검사하여 패턴이 만족되는지 확인
  - 그렇지 않은 경우 수신기는 오류가 발생했음을 확인, 사용자에게 알람
  - 통신 채널이 코드워드를 다른 유효한 출력 코드워드로 변환하여 입력하면 사각지대 체크 가능
### Single Parity Check
- 가장 간단한 코드
- k 개의 정보 비트를 가져와서 단일 체크 비트를 추가하여 코드워드를 구성하는 단일 패리티 검사 코드
- 패리티 검사 비트는 코드워드의 패리티가 짝수인지 확인
- 패리티 비트는 modulo 2 연산을 통해 계산됨
- 수신기는 수신한 코드워드의 1s 가 짝수인지 확인
- 사각지대 존재 가능
  - 홀수 비트를 변경하는 오류 패턴이 감지될 수 있음
  - 짝수로 매겨진 패턴은 감지할 수 없음
- 주로 문자가 7비트로 표시되고, 8번째 비트가 패리티 비트인 ASCII 코드에서 사용됨
### 예제
- 정보 프레임에 7개의 비트 (0, 1, 0, 1, 1, 0, 0)
- 패리티 체크 비트는 1로 계산 (0+1+0+1+1+0 = 1)
- 3비트에서 단일 비트 오류가 발생하면 오류가 감지
- 하지만 3, 5 와 같이 오류 비트가 2개인 경우 오류가 감지되지 않음
### how good is the single parity check code?
- 단일 패리티 검사 코드는 m개의 정보 비트당 1개의 중복 비트를 추가함
- 오버헤드는 1 / ( m + 1 )
- n비트의 코드워드를 전송한다고 가정,
- e1, e2 ... en 까지의 벡터 e1, e2는 i 전송 비트에서 오류가 발생하면 e = 1이고, 그렇지 않으면 e = 0이다
### Error Probability
- 많은 전송 채널에서 무작위로 비트 오류가 발생한다
- p를 단일 비트 전송에서 오류가 발생할 확률이라 할때, 비트 전송 시 오류가 발생할 확률은 1-p이다.
- n비트 코드워드에서 1비트 오류가 발생할 확률은 n 중에서 1을 선택하고 p를 곱한다음, (1-p)^(n-1)을 곱하는 것
- 1비트 오류는 P의 확률이고, 나머지 n-1 올바른 비트는 각각 1-p 의 확률로 발생하기 때문
- 오차 벡터에서 j비트 오류가 발생할 확률은 p^j를 곱한다음, (1-p)^(n-j)를 곱한 값 중에서 j를 선택하는 것
### Single Parity - Undectable errors
- 단일 패리티 검사로 감지할 수 없는 오류는 비트 오류가 짝수인 경우 발생
- n비트 코드워드의 경우 2비트 오류 패턴 2000개 중 약 1개만 탐지할 수 있다 (ppt 수식 참고)
***
### Two-Dimensional Parity Check
- 단일 패리티 검사의 오류 감지 기능을 향상시키는 간단한 방법
- k개의 정보 비트로 구성된 열을 정렬한 다음 각 열의 맨 아래에 체크 비트를 배치하는 것
- 각 행의 가장 오른쪽 비트는 행에 있는 다른 비트의 체크 비트
- 실제로 마지막 열이 패리티 열
- 비트 행렬로 인코딩된 결과는 모든 행이 짝수이고 모든 열의 패리티가 짝수인 패턴을 충족
### Error-detecting capability
- 전송 시 비트 스케일 매트릭스의 어느 위치에서든 하나 또는 두 개의 오류가 발생한다
- 적어도 하나의 행 또는 한 번의 패리티 검사가 실패하면 오류가 감지된다
- 매트릭스의 어느 곳에서든 오류가 세 개 발생하면 하나 이상의 행 또는 한 번의 패리티 검사가 실패하고 오류가 감지된다
- 일부 바이러스는 탐지불가
***
### 요약
- 단일 패리티 비트 코드는 ASCII에서 주로 사용된다
- 오버헤드는 낮지만 가장 많이 사용되는 1비트 오류를 포함하여 홀수 개의 오류를 감지할 수 있다
- 이진 시스템에서는 2차원 패리티 검사 코드를 사용, 1,2,3 비트 오류를 탐지할 수 있지만 오버헤드가 높다
***
# 2. 오류 제어 - 다항식 코드 (CRC)
***
### Polynomial Codes (다항식 코드)
- 다항식 코드에는 CRC라고 하는 순환 중복 검사의 형태로 체크 비트를 생성하는 작업이 포함됨
- 다항식 코드는 시프트 레지스터 회로에서 쉽게 구현됨
- 구현된 영역 제어 코드는 오류 감지 및 오류 수정 방법 모두에 가장 널리 사용됨
### Binary Polynomial Arithmetic
- 다항식 코드에서는 정보 문장, 코드워드 및 오차 벡터가 모두 이항 계수를 갖는 다항식으로 표현됨
- 다항식 코드는 정보 다항식에 해당하는 코드워드를 계산하기 위한 mod2 다항식 연산임
***
### Cyclic Redundancy Check (CRC)
- 순환 중복 검사인 CRC는 비트 문자열을 계수가 0과 1인 다항식의 표현으로 처리하는 것을 기반으로 하는 다항식 코드 사용
- k 비트 프레임은 x 거듭제곱 k-1에서 x 거듭제곱 0에 이르는 k개의 항을 포함하는 다항식의 계수 목록으로 간주됨, 이러한 다항식을 k-1이라 함
- 다항식 산술은 비트당 XOR 연산을 통해 수행된다는 점에 유의
### CRC Idea - Checkbits & Error Detection
- 코드워드에 n개의 비트가 있고 이 중 k는 정보 비트이고 n-k는 체크 비트인 코드를 다루고 있다고 가정
- k비트 정보는 n-k의 반도인 생성기 다항식 g(x)에 따라 체크 비트를 계산하는데 사용됨
- k비트 정보와 n-k 체크 비트는 통신 채널과 함께 전송됨
- 수신된 정보 비트는 체크 비트를 계산하는데 사용되며, 체크 비트는 수신된 체크 비트와 비교됨
- 체크 비트가 일치하면 정보가 오류 없음으로 승인됨
- 송신자와 수신자는 다항식 생성기에 대해 사전에 합의함
- 차수가 n-k인 생성기 다항식 g(x)가 주어지면 정보 비트가 k개, 차수가 k-1인 정보 다항식 x가 주어진다
### CRC 인코딩 절차
- i(x)에 x + n - k 를 곱하는 것. 이경우 n개의 0을 하위 위치에 배치함
- x의 거듭제곱을 n-k로 나누고, i(x)에 g(x)를 곱하는 것
- 나머지 i(x)의 다항식은 기껏해야 n-k-1 정도이므로 나머지를 CRC 검사 비트에 넣는다
- 마지막으로 나머지 r(x)를 x 거듭제곱 n-k i(x)에 더한다
- 체크 비트를 n-k개의 하위 위치에 놓는 방식으로 이루어짐
- 결과 다항식은 전송된 코드워드가 된다
### CRC Polynomial example
- k=4, n-k=3인 다항식 예제
- 생성기 다항식 g(x) = x^3 + x + 1
- 정보 블록은 (1,1,0,0) 4비트, i(x) = x^3 + x^2
- 인코딩 dividend : x^3 i(x) = x^6 + x^5
- ppt를 통한 이항식 계산 습득
***
### 요약
- 이진 다항식 코드와 이진 산술은 CRC 인코딩 및 체크 비트 계산의 핵심
***
# 3. CRC 기능, 인터넷 체크섬
***
### CRC 인코딩 - Recab
- CRC 인코딩은 체크비트를 생성하는 다항식 코드를 사용
- 첫번째 단계는 정보 다항식에 x+n-k를 곱하는것
- 두번째 단계는 이동 데이터 정보 다항식을 g(x)로 나누는 것
- 나머지 다항식인 r(x)는 CRC 체크비트
- 마지막으로 나머지 다항식 r(x)를 정보 다항식에 더함
- 결과로 생성되는 다항식은 전송된 코드워드가 된다
### Example
- Frame : 1 1 0 1 0 1 1 0 1 1
- Generator : 1 0 0 1 1
- Message after zero bits are appended : 1 1 0 1 0 1 1 0 1 1 0 0 0 0
- 프레임 메시지에는 4개의 0이 추가된다
- 제네레이터 차수가 4이기 때문에 차수가 더 낮다
- 주의할점 : 나머지 중간 다항식의 최고 거듭제곱이 약수의 최고 거듭제곱과 같거나 큰 경우에만 1
***
### CRC Capability Analysis
- CRC 기법으로 어떤 종류의 오류를 탐지할 수 있는가?
- 전송 오차 벡터 e(x)가 발생하고 e(x)는 오류 위치에 1이 있고 다른 곳에서는 0이 있다고 가정 <- 가산 오차 모델
- 송신기가 전송한 b(x) 대신 modulo 2나 산술을 사용하여 입력 코드 단어 b(x)에 비트 단위로 더하면 수신자는 이제 b(x) + e(x)를 받게 되며
- 수신자는 수신기 다항식을 나눔
- x가 g(x)의 배수인 경우 사각지대가 발생
- e(x)는 g(x)로 나눌 수 있지만 오류는 감지되지 않음
- 검출 능력이 좋은 g(x)를 선택하려면 어떻게 해야하는가?
### Designing Good Polynomial Codes
- 생성된 다항식을 선택해야 함
- 발생 가능한 오류 패턴은 g(x)의 배수가 아님
- 단일 오류는 e(x)가 x^i 와 같음을 의미
- g(x)에 항이 2개 이상 있는 경우 x와 i를 나눌 수 없으므로 강제로 오류 감지
- 이중 오차 e(x)는 x^i + x^j와 같다
- g에 항이 두개이상 있는경우 x와 i를 나눌 수 없다
***
### Internet Checksum
- IP, TCP, UDP를 포함한 인터넷 프로토콜은 CRC 다항식을 사용하는 대신, 체크 비트를 사용하여 오류 탐지
- 모든 라우터에서 체크섬을 다시 계산해야 하기 때문
- 체크섬 알고리즘은 강력한 오류 감지 기능 대신 구현이 용이하다는 점을 고려함
### Internet (IP) Checksum Algorithm
- IP 헤더는 특정 숫자, 16비트 워드의 L에서 b0, b1 .. bL-1
- 체크섬 bL의 16비트는 false로 계산됨
- 각 16비트 워드는 정수로 취급
- 16비트 단어의 합과 같은 x를 구하기
- x = (b0 + b1 + ... bL-1) modulo 2^16 - 1
- 소프트웨어에서 보완 산술을 사용하여 수행
- 체크섬을 수행하면, 헤더가 패턴을 만족해야 함
### Internet Checksum Example
- 4비트 단어 가정
- mod 2^4 -1
- b0 = 1100
- b1 = 1010
- 계산 과정 ppt 참고
***
### 요약
- 적절한 생성기 다항식 코드를 선택하는 것이 CRC 오류 감지 능력을 결정함
- 인터넷 체크섬은 탐지 기능보다는 구현의 용이성에 중점을 둠