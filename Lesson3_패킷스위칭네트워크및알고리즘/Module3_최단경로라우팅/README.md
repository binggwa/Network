# 1. 최단 경로 라우팅 - 링크 상태
***
### Counting to Infinity Problem
- 기존 라우팅 테이블의 변경으로 인해 라우터가 주변 라우터에 최소 비용을 브로드캐스트하여 컨버전스 속도를 높일 수 있어야 함
- 값에 비해 속도가 매우 느리다는 것이 문제
### Problem : Bad News Travels Slowly
- countig-to-infinity 문제 방지를 위해 거리 벡터 알고맂므에 몇가지 변경 사항
- 널리 구현된 방법 중 하나는 Split horizon
- 인접 노드가 최단 경로의 다음 노드인 경우 해당 목적지에 대한 최소 비용이 인접 노드로 전송되지 않음
- Split Horizon with Poisoned Reverse
- 노드가 최소한의 비용으로 모든 이웃 노드에 보낼 수 있음
- 인접 노드가 최단 경로의 다음 노드인 경우 해당 목적지에 대한 최소 비용은 무한대로 설정됨
### Link-State Algorithm
- 거리 벡터 라우팅의 근본적인 문제는 정보가 로컬 이웃과만 교환된다는 것
- 링크 상태 알고리즘은 글로벌 최적화를 추구함
- 기본 개념은 3단계
  - 각 소스 노드는 로컬 대 인접 링크 메트릭의 링크 상태 패킷을 만듬
  - 각 소스 노드가 링크 상태 패킷을 브로드캐스트하여 각 소스 노드가 전체 네트워크의 모든 노드와 링크 메트릭의 맵을 얻도록 함
  - 마지막으로 알고리즘을 적용하여 소스 노드에서 모든 대상 노드까지의 맵상의 최단 경로를 찾음
### Link-State Algorithm - Broadcasting
- 인접 패킷의 식별자와 해당 링크까지의 거리가 포함됨
- 플러딩으로 인해 링크 상태 패킷의 브로드캐스트가 수행될 수 있음
- 플러딩 규모를 제한하기 위해 소스 노드 식별자, 시퀀스 번호, 남은 시간을 추가하여 중복을 제거할 수 있었음
### Building Link State Packets
- 링크 상태 패킷의 예
- 노드가 6개인 네트워크 토폴로지 고려
- 각 노드에는 고유한 식별자, 시퀀스 번호, 출발 시간, 이웃 식별자 및 거리가 포함됨
- 시스템 재부팅과 같은 중요한 이벤트가 발생할 때 혹은 주기적으로 링크 데이터 패킷을 구축
***
# 2. 다익스트라 알고리즘
***
### 다익스트라 알고리즘
- 소스 노드에서 네트워크의 다른 모든 노드까지의 최단 경로를 찾기 위한 훌륭한 접근법
- 일반적으로 벨만-포드 알고리즘보다 효율적잊이만, 통신 네트워크의 경우 각 링크 비용이 양수가 됨
### Idea and Procedure
- 주요 아이디어는 과거 비용을 증가시켜 소스 노드에서 가장 가까운 노드를 점진적으로 식별하는 것
- 프로세스는 반복적임
- 첫 번째 반복에서는 소스 노드와 인접 노드에서 가장 가까운 노드를 찾음
- 두 번째 반복에서는 소스 노드에서 두 번째로 가까운 노드를 찾음 이 노드는 소스 노드의 인접 노드이거나 소스 노드와 가장 가까운 노드여야 함
- 세 번재 반복에서는 세 번재로 가까운 노드가 소스 노드 또는 처음 두 개의 가장 가까운 노드의 인접 노드여야 함
- k 번째 반복에서는 소스 노드에서 k 번재로 가까운 노드를 결정
- ppt 유사코드 참고
***
# 3. 링크 상태 라우팅, ATM 네트워크
***
### Reaction to Failure
- 인터넷의 많은 라우터는 거리 벡터 라우팅과 링크 상태 라우팅 프로토콜을 모두 지원함
- 도메인 내에서 노드는 메트릭 값을 얻기 위해 협력하고 정보를 교환해야 함
- 거리 벡터 라우팅에서는 인접 라우터가 라우팅 테이블을 교환함
- 정보를 제공하는 인접 서버로 가는 더 나은 새 경로가 있는지 확인하는 데 사용됨
- 문제는 네트워크 토폴로지의 변화에 느리게 적응한다는 것
- 반면, 링크 상태 라우팅의 실패에 대한 대응은 매우 빠름
- 링크에 장애가 발생하면 라우터는 링크 거리를 무한대로 설정하고 업데이트 패킷으로 네트워크를 가득 채움
- 모든 라우터는 즉시 링크 데이터베이스를 업데이트하고 최단 경로를 다시 계산함
### Why is Link State Better?
- 링크 상태 라우팅에는 많은 이점이 있음
- 한 번에 여러 메트릭을 지원 가능
- 링크 상태 라우팅은 대상에 대한 다중 경로를 지원하며 소스 라우팅의 경우 훨씬 더 유연함
### Problem of Link State Routing
- 단점은 플러딩으로 인한 기존의 중복 메시지
- 해결법
  - 업데이트된 각 메시지에 시퀀스 번호를 추가
  - 각 메시지에 지속 시간을 추가 등
### Source Routing vs. H-by-H
- 데이터그램 네트워크에서 각 라우터는 최단 경로를 따라 다음 홉을 결정하는 역할을 함
- 모든 라우터가 동일한 프로세스를 수행하는 경우 이는 홉별 라우팅
- 소스 라우팅은 대상 경로가 소스 라우터에 의해 결정되는 또 다른 라우팅 접근 방식
- 소스 라우팅을 사용하면 호스트가 네트워크에서 정보가 통과하는 경로를 제어할 수 있음
### Asynchronous Transfer Mode (ATM)
- 비동기 전송 모드(ATM)는 다양한 서비스 품질 지원을 제공하는 멀티플렉싱 및 스위칭 방법
- 셀이라고 하는 고정 길이 패킷을 적용함
- 각 셀의 길이는 5바이트 헤더를 포함하여 53바이트
- ATM은 연결 지향적이므로 end-to-end로 간주됨
- 실시간 음성 및 비디오, 디지털 전송을 위한 서킷 에뮬레이션, 대역폭이 보장되는 데이터 트래픽 등 더 광범위한 서비스를 지원함
### TDM vs. Packet Multiplexing
- ATM은 패킷 스위칭과 시분할 멀티플렉싱, TDM, 2차 스위칭과 같은 몇 가지 바람직한 기능을 결합함
- ppt의 표를 통해 TDM과 패킷 멀티플렉싱의 전체 기능 비교
### ATM : Attributes of TDM & Packet Switching
- 다양한 사용자가 생성한 정보 흐름은 셀로 변환되어 ATM 멀티플렉서로 전송됨
- 멀티플렉서는 셀을 하나 이상의 대기열로 정렬하고 셀이 전송되는 순서를 결정하는 몇 가지 스케쥴링 전략을 구현함
- 스케쥴링 전략의 목적은 다양한 흐름에 필요한 다양한 서비스 품질을 제공하는 것
- ATM은 특정 정보 흐름을 위한 전송 슬롯을 예약하지 않으므로 패킷 멀티플렉싱의 효율성을 제공함
- 비동기라는 용어를 사용하는 이유는 셀 전송이 어떤 프레임 구조와도 동기화되지 않기 때문
### ATM Virtual Connections
- ATM 네트워크는 연결 지향적이므로 셀을 전송하기 전에 연결을 설정해야 함
- 연결 설정 절차는 가상 회로 패킷 스위칭 네트워크에서 설명한 절차와 유사함
- 연결을 로컬에서 정의된 태그 체인에 의해 설정되는 가상 채널 연결이라고 함
- 또한 ATM은 가상 회로 패킷 스위칭과 매우 유사함
- 주요 차이점 중 하나는 ATM에서 고정된 길이의 짧은 셀을 사용한다는 점
- 이 접근 방식은 스위치 구현을 단순화하고 빠른 속도를 가능하게 함
### MPLS & ATM
- 처음에는 ATM이 패킷 스위칭보다 확장성이 뛰어난 것으로 간주됨
- 코어 패킷 네트워크를 위한 고속 다중 서비스 네트워크 기술로 구상됨
- 그러나 ATM 셀 헤더의 오버헤드로 인해 링크 효율성이 크게 저하되는 것으로 나타남
- ATM을 위한 세그멘테이션 및 리어셈블리를 구현해야 하는 필요성 또한 만만치 않은 것으로 판명남
- 다중 프로토콜 레이블 스위칭은 MPLS는 패킷 네트워크를 위한 대체 네트워크 기술로 도입됨
- 가변 길이 패킷을 허용하는 ATM이라는 레이블 스위칭 패러다임을 채택함
***
# 4. RIP 및 OSPF
***
### Routing Information Protocol (RIP)
- RIP 프로토콜은 BSD UNIX에서 배포되는 routed 라는 프로그램 기반
- 거리-벡터 알고리즘을 사용함
- 잘 알려진 포트 번호 520 를 통해 UDP 위에서 실행됨
- 최단 경로 계산에 사용되는 메트릭은 일반적으로 홉 수로 구성됨
- RIP는 일반적으로 네트워크 직경이 매우 작은 로컬 영역 환경에서 사용하기 위한 것이므로 최대 홉 수는 15개로 제한됨
- 16 값은 무한대를 나타내기 위한 것으로 한정되어 있음
### RIP Operation
- RIP를 구현하는 라우터는 링크 장애와 같은 토폴로지 변경을 처리하기 위해 30초마다 인접 라우터에 업데이트 메시지를 보냄
- 라우터는 180초 이내에 각 인접 라우터로부터 업데이트 메시지를 받을 것으로 예상함
- 30초보다 큰 값을 선택하는 이유는 RIP가 신뢰할 수 없는 프로토콜인 UDP를 사용하기 때문임
- 라우터가 한도 내에서 인접 디바이스로부터 업데이트 메시지를 받지 못하면 라우터와의 리읔에 장애가 발생한 것으로 간주하고 이에 해당하는 최소 비용을 무한대인 16으로 설정함
- 그러나 나중에 다른 인접 라우터로부터 라우터에 대한 유효 최소 비용을 받으면 라우터는 인피니티를 새 비용으로 대쳏마
- RIP는 역방향으로 분리된 스플릿 호라이즌을 사용하여 라우팅 루프를 줄임
- 라우터가 트리거된 업데이트를 구현하도록 요구하므로 컨버전스 속도가 빨라짐
### Deficiencies in RIP Protocol
- RIP의 단순성이 분명 장점임에도 불구하고 몇 가지 한계 존재
- 메트릭 사용 제한
- 컨버전스가 느림
- 메트릭에 지정된 작은 범위의 값에 홉 수를 사용하면
- 지원 코드가 네트워크 부하 조건을 계산할 수 없음
- 분할 위험은 컨버전스 속도를 높이는데 도움이 되지만 특정 유형의 장애가 발생하면 프로토콜이 제대로 작동하지 않을 수 있음
### Open Shortest Path First (OSPF)
- OSPF는 RIP의 일부 결함을 수정하기 위해 개발됨
- 이는 단일 조직에서 기술적으로 입증된 일련의 라우터 또는 네트워크로 느슨하게 정의되는 자율 시스템에서 작동함
- OSPF 프로토콜은 앞서 설명한 링크 상태 라우팅 접근 방식을 사용함
- 각 라우터가 인접 라우터로부터 각 인접 라우터까지의 거리만 학습하는 IP와는 다름
- OSPF를 사용하면 각 라우터가 전체 네트워크 토폴로지를 학습 가능
- 각 OSPF 라우터는 각 인접 라우터에 대한 링크 상태 라는 비용을 모니터링하고 링크 상태 정보를 다른 라우터로 플러딩함
- 각 라우터는 동일한 링크 상태 데이터베이스를 구축(전체 네트워크 토폴로지를 설명하는)
- OSPF를 사용하면 라우터를 루트로 하는 최단 경로 트리를 라우터가 구축가능
- 링크 상태 정보는 벡터보다 더 풍부한 정보를 제공하므로 OSPF는 일반적으로 네트워크에 장애가 발생할 경우 RIP보다 빠르게 수렴함
### OSPF Network
- 확장성을 개선하기 위해 OSPF는 자율 시스템을 영역이라는 여러 그룹으로 분할하여 중앙 백본 영역을 통해 상호 연결되는 2단계 계층 구조를 도입함
- 영역은 영역 ID라고 하는 32비트 숫자로 식별됨
- 특정 영역의 라우터만 해당 영역 내의 전체 토폴로지를 알고 해당 영역에 대한 링크 상태 정보의 플러딩을 제한하므로 프로토콜의 확장성이 향상됨
- 각 영역은 ID로 식별되는 백본 영역에 연결되어야 함
- 영역 경계 라우터는 다른 영역의 정보를 요약하고 백본 영역은 영역 간에 라우터 정보를 분배함
- OSPF에는 4가지 유형의 라우터가 정의되어 있음
- 내부 라우터는 모든 링크가 동일한 영역 내의 네트워크에 연결된 라우터임
- 영역 라우터는 링크가 2개 이상의 영역에 연결된 라우터임
- 백본 라우터는 링크가 백본에 연결된 라우터임
- 자율 시스템 경계 라우터는 BGP같은 외부 게이트웨이 프로토콜을 통해 익명 시스템 외부의 경로를 학습하는 다른 자율 시스템에 링크가 연결된 라우터
### OSPF Areas
- ppt를 통한 OSPF 영역 그림 참고